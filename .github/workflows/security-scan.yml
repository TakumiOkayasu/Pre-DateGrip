name: Security Scan

on:
  # Daily security scan at 00:00 JST (15:00 UTC)
  schedule:
    - cron: '0 15 * * *'
  # Manual trigger for on-demand scans
  workflow_dispatch:

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Default permissions (read-only)
permissions:
  contents: read

jobs:
  # Semgrep: Fast pattern-based security scanning
  semgrep:
    name: Semgrep Security Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write

    steps:
      - uses: actions/checkout@v6

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.14'
          allow-prereleases: true

      - name: Install Semgrep
        run: pip install semgrep

      - name: Run Semgrep Scan
        run: |
          semgrep scan \
            --config=auto \
            --config=p/security-audit \
            --config=p/owasp-top-ten \
            --json \
            --output=semgrep-results.json \
            --exclude='node_modules' \
            --exclude='build' \
            --exclude='dist' \
            --exclude='third_party' \
            . || true

      - name: Create Issues from Semgrep Results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Check if results file exists
            if (!fs.existsSync('semgrep-results.json')) {
              console.log('No Semgrep results file found');
              return;
            }

            const results = JSON.parse(fs.readFileSync('semgrep-results.json', 'utf8'));
            const findings = results.results || [];

            console.log(`Found ${findings.length} issues`);

            // Get existing issues with semgrep label (both open and closed to avoid duplicates)
            const existingIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              labels: 'semgrep',
              per_page: 100
            });

            // Build set of existing issue identifiers (rule + file, without line number for stability)
            const existingIdentifiers = new Set(existingIssues.map(i => {
              // Extract rule and file from title: "[Semgrep] ruleName in path/file.ts:123"
              const match = i.title.match(/\[Semgrep\] (.+) in (.+):\d+$/);
              return match ? `${match[1]}:${match[2]}` : i.title;
            }));

            // Filter to high/medium severity only to reduce noise
            const significantFindings = findings.filter(f => {
              const severity = (f.extra?.severity || 'INFO').toUpperCase();
              return ['ERROR', 'WARNING', 'HIGH', 'MEDIUM', 'CRITICAL'].includes(severity);
            });

            console.log(`${significantFindings.length} significant findings to process`);

            // Limit to 10 issues per run to avoid rate limiting
            const maxIssuesPerRun = 10;
            let createdCount = 0;

            for (const finding of significantFindings) {
              if (createdCount >= maxIssuesPerRun) {
                console.log(`Reached limit of ${maxIssuesPerRun} issues per run`);
                break;
              }

              const ruleId = finding.check_id || 'unknown';
              const ruleName = ruleId.split('.').pop();
              const filePath = finding.path || 'unknown';
              const line = finding.start?.line || 0;

              // Create identifier for deduplication (without line number)
              const identifier = `${ruleName}:${filePath}`;

              // Skip if issue already exists (same rule + file)
              if (existingIdentifiers.has(identifier)) {
                console.log(`Skipping duplicate: ${ruleName} in ${filePath}`);
                continue;
              }

              const title = `[Semgrep] ${ruleName} in ${filePath}:${line}`;
              const severity = (finding.extra?.severity || 'medium').toLowerCase();
              const message = finding.extra?.message || 'No description available';
              const codeSnippet = finding.extra?.lines || '';
              const refs = finding.extra?.metadata?.references || [];

              const body = [
                '## Security Issue Detected by Semgrep',
                '',
                `**Rule ID:** \`${ruleId}\``,
                `**Severity:** ${severity}`,
                `**File:** \`${filePath}\``,
                `**Line:** ${line}`,
                '',
                '### Description',
                message,
                '',
                '### Affected Code',
                '```',
                codeSnippet,
                '```',
                '',
                '### References',
                refs.length > 0 ? refs.map(r => `- ${r}`).join('\n') : 'None',
                '',
                '---',
                '*This issue was automatically created by the security scan workflow.*'
              ].join('\n');

              // Determine priority label based on severity
              const priorityLabel = ['high', 'critical', 'error'].includes(severity)
                ? 'priority:high'
                : 'priority:medium';

              try {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body,
                  labels: ['semgrep', priorityLabel]
                });
                console.log(`Created issue: ${title}`);
                existingIdentifiers.add(identifier);
                createdCount++;
              } catch (error) {
                console.error(`Failed to create issue: ${error.message}`);
              }
            }

            console.log(`Created ${createdCount} new issues`)

  # Note: CodeQL is handled by GitHub's default setup (Settings > Security > Code scanning)
  # Do not add CodeQL here to avoid "advanced configurations cannot be processed when default setup is enabled" error
